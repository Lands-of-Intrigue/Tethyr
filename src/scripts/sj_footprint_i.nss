// -----------------------------------------------------------------------------
//  sj_footprint_i
// -----------------------------------------------------------------------------
/*
    Common library for Sunjammer's Footprint System
    ===============================================

    A simple yet highly configurable method to produce a temporary trail of
    placeable "footprints" behind a PC or creature.

    PROPERTIES
    ==========

    Almost every aspect of a footprint can be configured using one or more
    custom properties. In addition some special properties can even affect the
    footprint's creator. All these properties are held as local variables on the
    creature or other objects.

    There are ways a property can be set:

        1.  By Default: every property has a default value enable the system to
            function on PCs and to minimise the number of properties that must
            be redefined or overridden. In fact it allows the system to function
            without setting any properties.

        2.  Redefining: any property can be redefined for a particular creature
            simply by adding the appropriate local variable to the creature at
            design time or run time. These settings will persist through a Stop/
            Start cycle for that creature.

        3.  Overriding: any property (including redefined properties) can be
            overridden using properties set on another object. This requires the
            StartWithOverrides method to be use and the properties will revert
            to their default or redefined values when the Start or Stop methods
            are called.


    Setting Properties: all properties are set by adding a local variable to an
    object. The variable's name is generated by adding "sj_footprint_" to that
    of the property. For example the "type" property is held in a local variable
    called "sj_footprint_type".


    Standard Properties: these are properties that affect the footprint itself:

        1.  type: footprints can be SINGLE or BIPED. SINGLE type footprints only
            require one blueprint and will normally appear behind the creature.
            BIPED type footprints require two blueprints (left and right) and
            will normally appear alternatively to the left and the right of the
            creature.

        2.  angle: the angle is relative to the creatures facing and is used to
            position the footprint. At runtime the BIPED type footprints will
            automatically negate the angle for the right footprint so you only
            need to set one value (for the left footprint). Use the following
            table as a guide:

                a.   0.0 = in front
                b.  90.0 = to the left
                c. -90.0 = to the right
                d. 180.0 = behind

        3.  duration: the duration determines how long it will exist for before
            it fades away.

        4.  interval: the interval is the time between each footprint being
            create. The interval and the creature's movement rate will dictate
            how far apart the footprints appear.

        5.  offset: the offset is the distance from the creature's position. For
            SINGLE type footprints this is normally the length of the stride but
            for BIPED type footprints this is normally half the width i.e. how
            far to the left or right of the creature the footprint will appear.

        6.  resref: for SINGLE type footprints the resref is the blueprint to be
            used but for BIPED type footprints the resref is the common root of
            the blueprint to be used. At runtime the BIPED type footprints will
            automatically concatenate an "l" or "r" onto the resref appropriate
            to the footprint being made so you only need to set one value. For
            example if the resref was "sj_footprint" the actual blueprints would
            be:

                a. single:          sj_footprint
                b. biped, left:     sj_footprintl
                c. biped, right:    sj_footprintr

        7.  visual: the visual is the ID number of a visual effect to be applied
            to the footprint. The ID number is the same as the actual value of
            the VFX_* constant or the row number in visualeffects.2da. For
            example the ID number of VFX_DUR_GLOW_RED is 411. At runtime the
            system will automatically determine if the VFX should be instant or
            permanent and if it should be applied at a location or on an object
            so you only need to set one value.


    Special Properties: these are properties that affect the creature creating
    the footprints:

        1.  ghost: the ghost special property will make the creature invisible
            and allow it to pathfind through other creatures.

        2.  silent: the silent special property will suppress the creature's
            footstep sound.

    Note: these effect can be automatically removed when using the Stop method
    by setting the bRemoveSpecial argument to TRUE.


    Data Types and Default Values: each property has a default value assigned so
    you only need to redefine it or override it when you require a different
    effect:

        Name        Type        Default Values
        ------------------------------------------------------------------------
        type        int         2 (SJ_FOOTPRINT_TYPE_BIPED)
        angle       string      "180.0" (single) or "90.0" (biped)
        duration    float       3.00
        interval    float       0.25
        offset      float       (value depends on appearance type)
        resref      string      "sj_footprint"
        visual      string      ""
        ghost       int         0 (FALSE)
        silent      int         0 (FALSE)

    Note: some properties are stored as strings even though they logically they
    should be either floats or ints. This is because 0.0 or 0 is a valid value
    for these properties and so we need some means to distinguish between a
    property that hasn't been set and one that has been set to 0. For example,
    contrast angle (where 0.0 degrees is valid) and duration (where 0.0 seconds
    is not valid).


    FUNCTIONS
    =========

    There are 4 functions to handle stopping and stopping the creation of
    footprints for a creature:

        - SJ_Footprint_Start
        - SJ_Footprint_StartWithOverrides
        - SJ_Footprint_Stop
        - SJ_Footprint_DelayedStop

    DelayedStop vs. DelayCommand(Stop): DelayedStop will take account of any
    Start commands issued before it expires and abort the stopping process. In
    contrast simply delaying the Stop command will terminate the footprints
    when the delay expires regardless of any Start commands issued in the
    interim. Both are valid techniques depending on the effect you require.


    There are 4 functions to handle the special States that can be set on the
    creature:

        - SJ_Footprint_ClearState
        - SJ_Footprint_GetState
        - SJ_Footprint_HasState
        - SJ_Footprint_SetState

    All states are defined as SJ_FOOTPRINT_STATE_* constants:

        1.  STOPPING: this state is automatically set when using the DelayedStop
            method and automatically cleared when using the Start methods.

        2.  SUPPRESSED: this state can be set when you want to temporarily
            suspend footprints, for example, when crossing water or during a
            conversation. Unlike the Start method suppressing footprints does
            not clear any overrides.


    LIMITATIONS
    ===========

    - currently limited to single (catch-all) and bipeds footprint types
    - requires 1.67 to use the default BIPED footprint model


    TODO @ 1.02
    ===========

    - random property values (where appropriate)
    - facing property

*/
// -----------------------------------------------------------------------------
/*
    Version 1.02 - 26 Mar 2006 - Sunjammer
    - added SJ_Footprint_StartWithOverrides
    - refactored code

    Version 1.01 - 03 Mar 2006 - Sunjammer
    - added locals to enable builders to define all properties
    - converted system to use footprint user-defined type
    - converted system to use self-calling function

    Version 1.00 - 25 Feb 2006 - Sunjammer
    - created

    Credits
    - Sir Elric: for suggestions and testing
*/
// -----------------------------------------------------------------------------
#include "sj_footprint_x"


// -----------------------------------------------------------------------------
//  CONSTANTS
// -----------------------------------------------------------------------------

// Footprint type enumeration
const int SJ_FOOTPRINT_TYPE_SINGLE  = 1;
const int SJ_FOOTPRINT_TYPE_BIPED   = 2;

// Default settings
const float SJ_FOOTPRINT_DEFAULT_DURATION   = 3.00;
const float SJ_FOOTPRINT_DEFAULT_INTERVAL   = 0.25;
const string SJ_FOOTPRINT_DEFAULT_RESREF    = "sj_footprint";    // + l or r

// System bit-flags for non-excluse states
const int SJ_FOOTPRINT_STATE_STOPPING       = 0x01;
const int SJ_FOOTPRINT_STATE_SUPPRESSED     = 0x02;

// Standard property variables
const string SJ_VAR_FOOTPRINT_ANGLE     = "sj_footprint_angle";     // string, creature
const string SJ_VAR_FOOTPRINT_DURATION  = "sj_footprint_duration";  // float, creature
const string SJ_VAR_FOOTPRINT_INTERVAL  = "sj_footprint_interval";  // float, creature
const string SJ_VAR_FOOTPRINT_OFFSET    = "sj_footprint_offset";    // float, creature
const string SJ_VAR_FOOTPRINT_RESREF    = "sj_footprint_resref";    // string, creature
const string SJ_VAR_FOOTPRINT_TYPE      = "sj_footprint_type";      // int, creature
const string SJ_VAR_FOOTPRINT_VISUAL    = "sj_footprint_visual";    // string, creature

// Special property variables
const string SJ_VAR_FOOTPRINT_GHOST     = "sj_footprint_ghost";     // boolean, creature
const string SJ_VAR_FOOTPRINT_SILENT    = "sj_footprint_silent";    // boolean, creature

// System variables
const string SJ_VAR_FOOTPRINT_ACTIVE    = "sj_footprint_active";    // boolean, creature
const string SJ_VAR_FOOTPRINT_FOOT      = "sj_footprint_foot";      // int, creature
const string SJ_VAR_FOOTPRINT_STATE     = "sj_footprint_state";     // int, creature
const string SJ_VAR_FOOTPRINT_STOPPING  = "sj_footprint_stopping";  // int, creature


// -----------------------------------------------------------------------------
//  STRUCTURES
// -----------------------------------------------------------------------------

struct footprint
{
    float   angle;
    float   duration;
    float   interval;
    float   offset;
    string  resref;
    int     type;
    int     vfx;
    int     vfxType;
};


// -----------------------------------------------------------------------------
//  PROTOTYPES
// -----------------------------------------------------------------------------

// Clears one or more states that have been set on oCreature. Use | (bitwise or)
// to clear multiple states, for example, to clear stopping and suppressed use:
// SJ_FOOTPRINT_STATE_STOPPING | SJ_FOOTPRINT_STATE_SUPPRESSED.
//  - oCreature:        any PC or creature
//  - nState:           any SJ_FOOTPRINT_STATE_* constant
void SJ_Footprint_ClearState(object oCreature, int nState);

// Schedules a point at which to stop creating footprints for oCreature. Whether
// they will actually stop being created when the delay expires depends on if
// they were stopped or started again in the interim.
//  - fDelay:           delay in seconds before Stop is actioned
//  - oCreature:        any PC or creature
//  - bRemoveSpecial:   TRUE (to remove any special property's effects) or FALSE
void SJ_Footprint_DelayedStop(float fDelay, object oCreature, int bRemoveSpecial=FALSE);

// Returns a value representing all the states currently set on the oCreature.
//  - oCreature:        any PC or creature
//  * Returns:          the value of one or more SJ_FOOTPRINT_STATE_* constants
//  * OnError:          returns 0 if creature is invalid or no states set
int SJ_Footprint_GetState(object oCreature);

// Returns TRUE if the specified state or states are set on oCreature. Use |
// (bitwise or) to check multiple states, for example, to check stopping and
// suppressed use: SJ_FOOTPRINT_STATE_STOPPING | SJ_FOOTPRINT_STATE_SUPPRESSED.
//  - oCreature:        any PC or creature
//  - nState:           any SJ_FOOTPRINT_STATE_* constant
//  * Returns:          TRUE (if the state is set on creature) or FALSE
//  * OnError:          returns FALSE if creature is invalid or no states set
int SJ_Footprint_HasState(object oCreature, int nState);

// Sets one or more states on oCreature.
// Use | (bitwise or) to SET multiple states, for example, to SET stopping and
// suppressed use: SJ_FOOTPRINT_STATE_STOPPING | SJ_FOOTPRINT_STATE_SUPPRESSED.
//  - oCreature:        any PC or creature
//  - nState:           any SJ_FOOTPRINT_STATE_* constant
void SJ_Footprint_SetState(object oCreature, int nState);

// Starts creating footprints for oCreature taking account of any properties it
// redefines.
//  - oCreature:        any PC or creature
void SJ_Footprint_Start(object oCreature);

// Starts creating footprints for oCreature taking account of any properties
// oSource overrides and any properties oCreature redefines.  Where a property
// is both overridden and redefined the override will take precedence.
//  - oCreature:        any PC or creature
//  - oSource:          any object
void SJ_Footprint_StartWithOverrides(object oCreature, object oSource);

// Stop creating footprints for oCreature.
//  - oCreature:        any PC or creature
//  - bRemoveSpecial:   TRUE (to remove any special property's effects) or FALSE
void SJ_Footprint_Stop(object oCreature, int bRemoveSpecial=FALSE);


// -----------------------------------------------------------------------------
//  FUNCTIONS: PRIVATE
// -----------------------------------------------------------------------------

// Called whenever a DelayedStop delay expires to determine if the footprints
// should in fact stop. The conditions to be met are that it is the last such
// call and that the footprints haven't already stopped or restarted.
//  - oCreature:        any PC or creature
//  - bRemoveSpecial:   TRUE (to remove any special property's effects) or FALSE
void SJ_Footprint_DoDelayedStop(object oCreature, int bRemoveSpecial=FALSE)
{
    // we are only interested in actioning the last delayed stop command, and
    // then only if the stopping flag is still raised: this allow multiple
    // delayed stops to be schedules and for the footprints to be stopped
    // and/or restarted in the interim
    if(DecLocalInt(oCreature, SJ_VAR_FOOTPRINT_STOPPING) == 0)
    {
        if(SJ_Footprint_HasState(oCreature, SJ_FOOTPRINT_STATE_STOPPING))
        {
            SJ_Footprint_Stop(oCreature, bRemoveSpecial);
        }
    }
}


// Self-calling function to configure and create each individual footprint.
//  - uFootprint:       a user-defined footprint type
void SJ_Footprint_DoFootprint(struct footprint uFootprint)
{
    string sFootprint;
    struct polar uOffset;

    object oCreature = OBJECT_SELF;

     // check a guard condition
    if(GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_ACTIVE) == FALSE)
        return;

    // are we currently suppressing footprints?
    if(SJ_Footprint_HasState(oCreature, SJ_FOOTPRINT_STATE_SUPPRESSED))
    {
        // schedule a callback without creating a footprint
        DelayCommand(uFootprint.interval, SJ_Footprint_DoFootprint(uFootprint));
        return;
    }

    // decompose owner's current location
    object oArea = GetArea(oCreature);
    vector vPosition = GetPosition(oCreature);
    float fFacing = GetFacing(oCreature);

    // determine type-specific properties: position and resref
    if(uFootprint.type == SJ_FOOTPRINT_TYPE_SINGLE)
    {
        // calculate the absolute position where the foot will fall by using the
        // angle and offset relative to the owner's poition
        uOffset.angle = fFacing + uFootprint.angle;
        uOffset.radius = uFootprint.offset;
        vPosition += PolarToVector(uOffset);

        // get the resref
        sFootprint = uFootprint.resref;
    }
    else
    {
        // change what foot are we on: 1 = left, 0 = right
        int nFoot = (GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_FOOT) + 1) % 2;
        SetLocalInt(oCreature, SJ_VAR_FOOTPRINT_FOOT, nFoot);

        // calculate the absolute position where the foot will fall by using the
        // angle and offset relative to the owner's poition
        uOffset.angle = fFacing + (nFoot ? uFootprint.angle : -uFootprint.angle);
        uOffset.radius = uFootprint.offset;
        vPosition += PolarToVector(uOffset);

        // build the resref for the current foot
        sFootprint = uFootprint.resref + (nFoot ? "l" : "r");
    }

    // reconstruct new location
    // NOTE: placeables facings are 180 degrees out sync with creatures
    location lFootprint = Location(oArea, vPosition, NormalizeAngle(fFacing - 180.0));

    // create the footprint
    object oFootprint = CreateObject(OBJECT_TYPE_PLACEABLE, sFootprint, lFootprint,FALSE,"sFootTrack");
    SetPlotFlag(oFootprint, TRUE);
    SetLocalInt(oFootprint,"nTrackRace",GetRacialType(oCreature));
    SetLocalInt(oFootprint,"nTrackGend",GetGender(oCreature));
    SetLocalInt(oFootprint,"nTrackWeight",GetWeight(oCreature));
    SetLocalObject(oFootprint,"oCreator",oCreature);

    // apply any visual effect
    if(uFootprint.vfx > VFX_NONE)
    {
        // determine the appropriate method: FNF and IMP effects are applied
        // instantly at the footprint's location while all others are applied
        // permanently to the footprint object itself
        if(uFootprint.vfxType == DURATION_TYPE_INSTANT)
        {
            effect eVFX = EffectVisualEffect(uFootprint.vfx);
            ApplyEffectAtLocation(DURATION_TYPE_INSTANT, eVFX, lFootprint);
        }
        else
        {
            effect eVFX = EffectVisualEffect(uFootprint.vfx);
            ApplyEffectToObject(DURATION_TYPE_PERMANENT, eVFX, oFootprint);
        }
    }

    // schedule it to self-destruction
    // NOTE: the footprint is responsible for it's own destruction as its owner
    // may cease to exist before the duration has elapsed
    AssignCommand(oFootprint, DelayCommand(uFootprint.duration, DestroyObject(oFootprint)));

    // schedule a callback
    DelayCommand(uFootprint.interval, SJ_Footprint_DoFootprint(uFootprint));
}


// Returns a string describing the footprints properties.
//  - uFootprint:       a user-defined footprint type
//  * Returns:          a string
string SJ_Footprint_FooprintToString(struct footprint uFootprint)
{
    return "(T: "  + IntToString(uFootprint.type)
        + ", R: "  + uFootprint.resref
        + ", A: "  + FloatToString(uFootprint.angle, 0, 2)
        + ", D: "  + FloatToString(uFootprint.duration, 0, 2)
        + ", I: "  + FloatToString(uFootprint.interval, 0, 2)
        + ", O: "  + FloatToString(uFootprint.offset, 0, 2)
        + ", V: "  + IntToString(uFootprint.vfx)
        + ", VT: " + IntToString(uFootprint.vfxType)
        + ")";
}


// Returns a string equivalent for the default angle of the specified footprint
// type.
//  - nType:            any SJ_FOOTPRINT_TYPE_* constant
//  * Returns:          a numeric string
//  * OnError:          returns an empty string
string SJ_Footprint_GetDefaultAngle(int nType)
{
    string sRet;

    switch(nType)
    {
        case SJ_FOOTPRINT_TYPE_SINGLE:  sRet = "180.0"; break;
        case SJ_FOOTPRINT_TYPE_BIPED:   sRet =  "90.0"; break;
    }
    return sRet;
}


// Returns a string equivalent for the default offset of the specified creature.
//  - oCreature:        any PC or creature
float SJ_Footprint_GetDefaultOffset(object oCreature)
{
    int nAppearance = GetAppearanceType(oCreature);
    string sOffset = Get2DAString("appearance", "CREPERSPACE", nAppearance);
    return StringToFloat(sOffset) / 3;
}


// Creates and configures a footprint for oCreature by redefining the default
// properties with any properties specified on oCreature and overriding any
// redefined or default properties with any properties specified on oSource.
//  - oCreature:        any PC or creature
//  - oSource:          any object
struct footprint SJ_Footprint_Initialise(object oCreature, object oSource=OBJECT_INVALID)
{
    int nType;
    float fDuration, fInterval, fOffset;
    string sAngle, sResref, sVisual;
    struct footprint uFootprint;

    // -------------------------------------------------------------------------
    //  Overriden?
    // -------------------------------------------------------------------------

    // if a source of overrides has been specified check each property to see if
    // in fact it has been overridden

    if(GetIsObjectValid(oSource))
    {
        nType       = GetLocalInt(oSource, SJ_VAR_FOOTPRINT_TYPE);
        sAngle      = GetLocalString(oSource, SJ_VAR_FOOTPRINT_ANGLE);
        fDuration   = GetLocalFloat(oSource, SJ_VAR_FOOTPRINT_DURATION);
        fInterval   = GetLocalFloat(oSource, SJ_VAR_FOOTPRINT_INTERVAL);
        fOffset     = GetLocalFloat(oSource, SJ_VAR_FOOTPRINT_OFFSET);
        sResref     = GetLocalString(oSource, SJ_VAR_FOOTPRINT_RESREF);
        sVisual     = GetLocalString(oSource, SJ_VAR_FOOTPRINT_VISUAL);
    }

    // -------------------------------------------------------------------------
    //  Redefined or Default?
    // -------------------------------------------------------------------------

    // if any property hasn't been overridden check the creature to see if it
    // has been redefined and if not then use the default setting

    if(nType == 0) nType = GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_TYPE);
    if(nType == 0) nType = SJ_FOOTPRINT_TYPE_BIPED;

    if(sAngle == "") sAngle = GetLocalString(oCreature, SJ_VAR_FOOTPRINT_ANGLE);
    if(sAngle == "") sAngle = SJ_Footprint_GetDefaultAngle(nType);

    if(fDuration == 0.0) fDuration = GetLocalFloat(oCreature, SJ_VAR_FOOTPRINT_DURATION);
    if(fDuration == 0.0) fDuration = SJ_FOOTPRINT_DEFAULT_DURATION;

    if(fInterval == 0.0) fInterval = GetLocalFloat(oCreature, SJ_VAR_FOOTPRINT_INTERVAL);
    if(fInterval == 0.0) fInterval = SJ_FOOTPRINT_DEFAULT_INTERVAL;

    if(fOffset == 0.0) fOffset = GetLocalFloat(oCreature, SJ_VAR_FOOTPRINT_OFFSET);
    if(fOffset == 0.0) fOffset = SJ_Footprint_GetDefaultOffset(oCreature);

    if(sResref == "") sResref = GetLocalString(oCreature, SJ_VAR_FOOTPRINT_RESREF);
    if(sResref == "") sResref = SJ_FOOTPRINT_DEFAULT_RESREF;

    if(sVisual == "") sVisual = GetLocalString(oCreature, SJ_VAR_FOOTPRINT_VISUAL);
    if(sVisual == "") sVisual = IntToString(VFX_NONE);

    // -------------------------------------------------------------------------
    //  Construct Footprint
    // -------------------------------------------------------------------------

    uFootprint.type     = nType;
    uFootprint.angle    = StringToFloat(sAngle);
    uFootprint.duration = fDuration;
    uFootprint.interval = fInterval;
    uFootprint.offset   = fOffset;
    uFootprint.resref   = sResref;
    uFootprint.vfx      = StringToInt(sVisual);

    if(uFootprint.vfx > VFX_NONE)
    {
        // read the vfx duration type and convert into a standard duration type
        string sVDT = Get2DAString("visualeffects", "Type_FD", uFootprint.vfx);
        uFootprint.vfxType = (sVDT == "F") ? DURATION_TYPE_INSTANT : DURATION_TYPE_PERMANENT;
    }

    // -------------------------------------------------------------------------
    //  Special Properties
    // -------------------------------------------------------------------------

    // if the ghost flag is raised apply the CSG and CSI effects
    // NOTE: while creating and applying the effects in line is ugly it allows
    // the creature to become the effect's creator which enables us to minimise
    // the impact of removing the VFX
    if(GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_GHOST))
    {
        AssignCommand(oCreature, ApplyEffectToObject(DURATION_TYPE_PERMANENT, EffectCutsceneGhost(), oCreature));
        AssignCommand(oCreature, ApplyEffectToObject(DURATION_TYPE_PERMANENT, EffectVisualEffect(VFX_DUR_CUTSCENE_INVISIBILITY), oCreature));
    }

    // if the silent flag is raised suppress any footstep sounds
    if(GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_SILENT))
    {
        SetFootstepType(FOOTSTEP_TYPE_NONE);
    }

    // -------------------------------------------------------------------------
    //  Finish
    // -------------------------------------------------------------------------

    // return initialised footprint user-defined type
    return uFootprint;
}


// -----------------------------------------------------------------------------
//  FUNCTIONS: PUBLIC
// -----------------------------------------------------------------------------

void SJ_Footprint_ClearState(object oCreature, int nState)
{
    // clear specified state(s)
    nState = SJ_Footprint_GetState(oCreature) &~ nState;
    SetLocalInt(oCreature, SJ_VAR_FOOTPRINT_STATE, nState);
}


void SJ_Footprint_DelayedStop(float fDelay, object oCreature, int bRemoveSpecial=FALSE)
{
    // increase the "stopping count" and set the "stopping state": together
    // these ensure we have adequate protection against DelayedStops that have
    // been scheduled but are no longer required:
    //
    //  - the stopping count acts as an outer guard condition to ensure that
    //    where DelayedStop is called again before a pre-existing DelayedStop
    //    has expired that only the later one is actioned
    //
    //  - the stopping state acts as an inner guard condition and a DelayedStop
    //    will only be actioned when the delay expires if the state is still set
    //    i.e. it hasn't been cleared by calling the Start or Stop method.
    IncLocalInt(oCreature, SJ_VAR_FOOTPRINT_STOPPING);
    SJ_Footprint_SetState(oCreature, SJ_FOOTPRINT_STATE_STOPPING);

    // schedule the creature to potentially action the stop
    DelayCommand(fDelay, SJ_Footprint_DoDelayedStop(oCreature, bRemoveSpecial));
}


int SJ_Footprint_GetState(object oCreature)
{
    return GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_STATE);
}


int SJ_Footprint_HasState(object oCreature, int nState)
{
    // use bitwise and to get the common bits then compare the result against
    // the specified state or states to ensure they are equal
    return (SJ_Footprint_GetState(oCreature) & nState) == nState;
}


void SJ_Footprint_SetState(object oCreature, int nState)
{
    // add specified state or states
    nState |= SJ_Footprint_GetState(oCreature);
    SetLocalInt(oCreature, SJ_VAR_FOOTPRINT_STATE, nState);
}


void SJ_Footprint_Start(object oCreature)
{
    SJ_Footprint_StartWithOverrides(oCreature, OBJECT_INVALID);
}


void SJ_Footprint_StartWithOverrides(object oCreature, object oSource)
{
    // starting fresh footprints so clear the stopping state
    SJ_Footprint_ClearState(oCreature, SJ_FOOTPRINT_STATE_STOPPING);

    // pre-emptive abort: are footprints active?
    if(GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_ACTIVE))
        return;

    // footprints are now active
    SetLocalInt(oCreature, SJ_VAR_FOOTPRINT_ACTIVE, TRUE);

    // initialise the creature's footprint properties
    // NOTE: this function is pre-empted so no need to check the state here
    struct footprint uFootprint = SJ_Footprint_Initialise(oCreature, oSource);

    // make the first call to the footprinting function
    AssignCommand(oCreature, SJ_Footprint_DoFootprint(uFootprint));
}


void SJ_Footprint_Stop(object oCreature, int bRemoveSpecial=FALSE)
{
    // footprints have stopped so clear the stopping state
    SJ_Footprint_ClearState(oCreature, SJ_FOOTPRINT_STATE_STOPPING);

    // footprints are no longer active
    DeleteLocalInt(oCreature, SJ_VAR_FOOTPRINT_ACTIVE);

    // should we reverse the effects of any special properties?
    if(bRemoveSpecial)
    {
        // if the ghost flag is raised remove the CSG and CSI effects
        // NOTE: due to engine limitations removing the CSI VFX will strip away
        // all other VFXs created and applied by the creature to itself
        if(GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_GHOST))
        {
            // iterate through every effect on the creature and remove CSG and
            // any VFX it created
            effect eCur = GetFirstEffect(oCreature);
            while(GetIsEffectValid(eCur))
            {
                if(GetEffectCreator(eCur) == oCreature)
                {
                    switch(GetEffectType(eCur))
                    {
                        case EFFECT_TYPE_CUTSCENEGHOST:
                        case EFFECT_TYPE_VISUALEFFECT:
                        {
                            RemoveEffect(oCreature, eCur);
                            break;
                        }
                    }
                }
            }
        }

        // if the silent flag is raised revive default footstep sounds
        if(GetLocalInt(oCreature, SJ_VAR_FOOTPRINT_SILENT))
        {
            SetFootstepType(FOOTSTEP_TYPE_DEFAULT);
        }
    }
}


